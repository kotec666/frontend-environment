# React: Основы и Современные Практики

## Содержание
1. [Основные концепции](#основные-концепции)
2. [Компоненты](#компоненты)
3. [Хуки](#хуки)
4. [Оптимизация](#оптимизация)
5. [Продвинутые возможности](#продвинутые-возможности)
6. [Серверные функции](#серверные-функции)
7. [Ограничения и альтернативы](#ограничения-и-альтернативы)
8. [h.o.c.](#hoc)
9. [Дополнение](#дополнение)

## React - популярная библиотека, которая позволяет удобно и оптимизированно работать с DOM деревом, имеет компонентный подход, JSX

## Основные концепции

### Virtual DOM
React использует Virtual DOM для оптимизации обновлений интерфейса:
- Создает виртуальное представление DOM из проксированных js объектов, которые хранят структура дерева компонентов и их текущее состояние
- После каждого изменения состояния React сравнивает новое и предыдущее состояние по ключам и древу, чтобы узнать, какие части приложения изменились
- Применяет только необходимые изменения к реальному DOM
- Batching - группирование нескольких функций обновления состояния компонентов в один рендеринг (несколько useState - рендер один раз)
- Rerender компонентов вызывают: state, props, изменение ключей в списках, перерендер родительского компонента

### Reconciliation (Согласование)
- Алгоритм diffing для сравнения Virtual DOM
- Определяет минимальный набор изменений
- Применяет изменения к реальному DOM


### Fiber Architecture
React Fiber (с версии 16):
- Инкрементальный рендеринг
- Возможность приостановки и возобновления рендеринга
- Приоритизация обновлений
- Улучшенная производительность для анимаций

## Компоненты

### Типы компонентов
| Тип            | Описание            | Особенности                          |
|----------------|---------------------|--------------------------------------|
| Функциональные | Современный подход  | Используют хуки, проще тестировать   |
| Классовые      | Устаревший подход   | Используют методы жизненного цикла   |

### Управляемые vs Неуправляемые компоненты
| Тип           | Управление                     | Пример                                              |
|---------------|--------------------------------|-----------------------------------------------------|
| Управляемые   | React контролирует состояние   | `<input value={state} onChange={handleChange} />`   |
| Неуправляемые | DOM хранит состояние           | `<input ref={inputRef} />`                          |

### Refs
| Метод      | Компоненты      | Поведение                               |
|------------|-----------------|-----------------------------------------|
| useRef     | Функциональные  | Сохраняет значение между рендерами      |
| createRef  | Классовые       | Создает новый объект при каждом рендере |
- В React 19+ можно использовать ref без forwardRef

### Сравнение методов жизненного цикла - mount, update, unmount
| Классовый компонент      | Функциональный компонент                 | Описание                                   | Пример                                                                                                                                 |
|--------------------------|------------------------------------------|--------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------|
| constructor              | -                                        | Инициализация состояния                    | ```jsx constructor(props) { super(props); this.state = { count: 0 }; } ```                                                             |
| componentDidMount        | useEffect(() => {}, [])                  | Выполняется после монтирования             | ```jsx useEffect(() => { console.log('Mounted'); }, []); ```                                                                           |
| componentDidUpdate       | useEffect(() => {}, [deps])              | Выполняется после обновления               | ```jsx useEffect(() => { console.log('Updated'); }, [count]); ```                                                                      |
| componentWillUnmount     | useEffect(() => { return () => {} }, []) | Выполняется перед размонтированием         | ```jsx useEffect(() => { return () => { console.log('Unmounted'); }; }, []); ```                                                       |
| shouldComponentUpdate    | React.memo                               | Контроль перерендера                       | ```jsx const MemoizedComponent = React.memo(Component, (prevProps, nextProps) => { return prevProps.value === nextProps.value; }); ``` |
| getDerivedStateFromProps | useState + useEffect                     | Обновление состояния на основе пропсов     | ```jsx useEffect(() => { setState(props.value); }, [props.value]); ```                                                                 |
| getSnapshotBeforeUpdate  | useLayoutEffect                          | Получение информации перед обновлением DOM | ```jsx useLayoutEffect(() => { const height = elementRef.current.scrollHeight; return height; }); ```                                  |
| componentDidCatch        | -                                        | Обработка ошибок                           | Используется Error Boundary                                                                                                            |

## Хуки

### Основные хуки
| Хук             | Назначение              | Особенности                                                                                         |
|-----------------|-------------------------|-----------------------------------------------------------------------------------------------------|
| useState        | Управление состоянием   | Триггерит ререндер при изменении                                                                    |
| useEffect       | Побочные эффекты        | Выполняется после рендера, если не передавать второй параметр, то будет вызываться на каждый рендер |
| useLayoutEffect | Побочные эффекты        | Выполняется до отрисовки, блокирует рендер                                                          |
| useCallback     | Мемоизация функций      | Предотвращает лишние рендеры                                                                        |
| useMemo         | Мемоизация значений     | Кэширует результаты вычислений                                                                      |
| useRef          | Ссылки на DOM/значения  | Не триггерит ререндер                                                                               |
| useContext      | Доступ к контексту      | Передает данные через дерево компонентов                                                            |

### Сравнение useEffect и useLayoutEffect
| Характеристика     | useEffect            | useLayoutEffect           |
|--------------------|----------------------|---------------------------|
| Время выполнения   | После отрисовки      | До отрисовки              |
| Блокировка рендера | Нет                  | Да                        |
| Использование      | Асинхронные операции | Синхронные операции с DOM |

### Дополнительные хуки
| Хук                  | Назначение                    | Пример использования                                                                                                 |
|----------------------|-------------------------------|----------------------------------------------------------------------------------------------------------------------|
| useReducer           | Сложное состояние             | Управление формой                                                                                                    |
| useTransition        | Отложенные обновления         | Оптимизация UI                                                                                                       |
| useDeferredValue     | Отложенное значение           | Оптимизация рендеринга                                                                                               |
| useId                | Генерация уникальных ID       | Формы, списки                                                                                                        |
| useImperativeHandle  | Настройка ref                 | Кастомные методы компонента                                                                                          |
| useActionState       | Управление состоянием формы   | Оптимизация форм с серверными действиями                                                                             |
| useDebugValue        | Отладка в React DevTools      | Улучшение отладки кастомных хуков                                                                                    |
| useInsertionEffect   | Вставка стилей                | Работа с CSS-in-JS                                                                                                   |
| useOptimistic        | Оптимистичные обновления      | Улучшение UX при асинхронных операциях - (добавление комментария до его загрузки на сервер / при ошибке откатит UI ) |
| useSyncExternalStore | Подписка на внешние хранилища | Интеграция с внешними стейт-менеджерами (стейт менеджеры по дефолту используют его, смысла в хуке почти нет)         |

### Подробное описание дополнительных хуков

#### useActionState
```jsx
// Управление состоянием формы с серверными действиями
const [state, formAction] = useActionState(async (prevState, formData) => {
  // Серверное действие
  const result = await submitForm(formData);
  return result;
}, initialState);
```

#### useDebugValue
```jsx
// Улучшение отладки кастомных хуков
function useCustomHook(value) {
  useDebugValue(value, v => `Значение: ${v}`);
  return value;
}
```

#### useInsertionEffect
```jsx
// Вставка стилей перед рендерингом
useInsertionEffect(() => {
  const style = document.createElement('style');
  style.textContent = `
    .my-class { color: red; }
  `;
  document.head.appendChild(style);
  return () => style.remove();
}, []);
```

#### useOptimistic
```jsx
// Оптимистичные обновления UI
const [optimisticState, addOptimistic] = useOptimistic(
  state,
  (currentState, optimisticValue) => ({
    ...currentState,
    items: [...currentState.items, optimisticValue]
  })
);
```

#### useSyncExternalStore
```jsx
// Подписка на внешнее хранилище
const state = useSyncExternalStore(
  subscribe, // Функция подписки
  getSnapshot, // Функция получения снапшота
  getServerSnapshot // Опциональная функция для SSR
);
```

## Оптимизация

### Методы оптимизации
1. **React.memo**
   - Мемоизация компонентов
   - Предотвращает лишние рендеры
   ```jsx
   const MemoizedComponent = React.memo(Component);
   ```

2. **useMemo и useCallback**
   - Кэширование значений и функций
   - Оптимизация производительности
   ```jsx
   const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
   const memoizedCallback = useCallback(() => doSomething(a, b), [a, b]);
   ```

3. **Profiler**
   - Измерение производительности
   ```jsx
   <Profiler id="App" onRender={onRenderCallback}>
     <App />
   </Profiler>
   ```

## Продвинутые возможности

### Suspense
- Отложенная загрузка компонентов
- Fallback-интерфейс во время загрузки
```jsx
<Suspense fallback={<Loading />}>
  <LazyComponent />
</Suspense>
```

### Portal
- Рендеринг вне DOM-иерархии
- Используется для модальных окон
```jsx
ReactDOM.createPortal(children, domNode);
```

### PropTypes
- Валидация типов пропсов
- Отладка в development режиме
```jsx
Component.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};
```

## Серверные функции

### Функции для работы с ресурсами и модулями
| Функция       | Назначение                                  | Пример                                                    |
|---------------|---------------------------------------------|-----------------------------------------------------------|
| use           | Чтение ресурса                              | `const data = use(resource)`                              |
| cache         | Кэширование функций в серверных компонентах | `const cachedFn = cache(fn)`                              |
| preconnect    | Предварительное соединение                  | `preconnect('https://api.example.com')`                   |
| prefetchDNS   | Предварительный DNS-запрос                  | `prefetchDNS('example.com')`                              |
| preload       | Предварительная загрузка                    | `preload('/image.png')`                                   |
| preinit       | Предварительная инициализация               | `preinit('/script.js')`                                   |
| preinitModule | Предварительная инициализация модулей       | ```jsx preinitModule('/module.js', { as: 'script' }); ``` | Оптимизация загрузки критических модулей                                                   |
| preloadModule | Предварительная загрузка модулей            | ```jsx preloadModule('/module.js'); ```                   | Улучшение производительности загрузки не критических модулей                               |

### Функции рендеринга
| Функция                 | Назначение           | Пример                                                   |
|-------------------------|----------------------|----------------------------------------------------------|
| renderToPipeableStream  | Потоковый рендеринг  | `const { pipe } = renderToPipeableStream(reactNode)`     |
| renderToReadableStream  | Асинхронный поток    | `const stream = await renderToReadableStream(reactNode)` |
| renderToStaticMarkup    | Статический HTML     | `const html = renderToStaticMarkup(reactNode)`           |

### Дополнительные функции React
| Функция           | Назначение                            | Пример использования                                                  | Применение                                                                                 |
|-------------------|---------------------------------------|-----------------------------------------------------------------------|--------------------------------------------------------------------------------------------|
| act               | Тестирование асинхронных операций     | ```jsx await act(async () => { await performAsyncOperation(); }); ``` | Используется в тестах для корректной обработки асинхронных обновлений состояния            |
| startTransition   | Отложенные обновления UI              | ```jsx startTransition(() => { setState(newState); }); ```            | Оптимизация производительности при тяжелых обновлениях, помечает обновления как не срочные |
| captureOwnerStack | Отладка и логирование                 | ```jsx const stack = captureOwnerStack(); console.log(stack); ```     | Получение стека компонентов для отладки и логирования                                      |


## Ограничения и альтернативы

### Минусы React
1. **SEO**
   - Проблемы с индексацией SPA
   - Требуется SSR/SSG (Next.js)

2. **Сложность настройки**
   - Сложная конфигурация SSR
   - Большой размер бандла

3. **Не всегда оптимален**
   - Простые статические сайты (лучше HTML + CSS)
   - SEO-критичные проекты (лучше Next.js)

### Иммутабельность
- Избегайте прямой мутации объектов
- Используйте spread оператор 
```javascript
// Плохо
obj.age = 26;

// Хорошо
const newObj = { ...obj, age: 26 };
```

## HOC

```jsx
   // hoc пример
   const HighOrderComponent = (props) => {
      return props.children
   }
   <HighOrderComponent>
      <div>пример</div>
   </HighOrderComponent>

   // render props пример
   const RenderPropsComponent = ({component}) => {
      return component
   }
   <RenderPropsComponent component={<div>пример</div>} />
```

## Дополнение

### Чистая функция возвращает каждый раз ожидаемое, не рандомное значение

### В unmount мы отписываемся от сокетов, таймеров и пр.

### Cлучаи применения useCallback и useMemo:
**1. в useCallback оборачиваются ф-ии когда они передаются в React.memo компоненты, чтобы они не триггерили перерендер мемоизированного компонента.**

**2. в useCallback оборачиваются ф-ии, которые попадают в массив зависимостей useEffect.**